**Компонент Toast**

**Использование:** <br/>
Для корректного использования данного компонента, необходимо добавить компонент `<ToastsContainer />` на вашу страницу. Лучше всего это сделать в layout, который используется на всех страницах. Далее просто импортируем `toast` и вызываем один из его методов, который нам необходим.

**Файлы компонента:** <br/>
1) consts.ts - файл, хранящий в себе цвета и варианты текста тостов.
2) index.tsx - файл, хранящий и реализующий в себе всю основную логику рендеринга тостов.
3) styled.tsx - стилизованные врапперы
4) Toast.tsx - стилизованный компонент тоста, который выводим пользователю.
5) ToastsContainer.tsx - стилизованный контейнер для тостов.
6) types.ts - типы используемые данными компонентами.

**Логика работы компонента:**<br/>
Заводим константу `containerId` которая хранит в себе id контейнера тостов внутри файла consts.ts. <br>
В файле index.tsx объявляем переменную root со значением null, эта переменная в дальнейшем будет использоваться для хранения рута, созданого через createRoot(). <br>
В этом же файле создаем массив toasts, который будет в себе хранить все тосты, которые необходимо показывать пользователю. Тосты из себя представляют объект со следующими свойствами: 
` content: ReactNode;
  key: string;
  variant: ToastVariantMessage;` <br>
  - content в нашем случае, это ReactNode, для передачи в тост не только текста.<br>
   - key - ключ, по которому будем удалять тост
   - variant - вариант отображение (успешный тост, ошибка, информационный, предупреждающий). <br><br>
Так же заводим объект `toastCommands` - это объект команд который будет экспортироваться из нашего файла, и метод которого по итогу и будет вызываться в коде. Пока он пустой, присвоим значением позже.
<br>
После того, как все переменный объявлены мы берем все возможные variants (они хранятся в enum ToastVariantMessage) тоста и циклом проходимся по ним. 

```
Object.values(ToastVariantMessage).forEach((variant) => {
  toastCommands[variant] = (content: ReactNode ) => {
    toasts.push({ content, variant, key: Date.now() + "" });
    renderToasts();
  };
});
```
При каждой итерации циклы мы берем variant, и передаем его в toastCommands как ключ свойства объекта, а в это свойство присваиваем callback, который принимает в себя content типа ReactNode. <br> Внутри этого коллбека мы добавляем в конец массива объект тоста, который включает в себя `content`, который мы получили в качестве аргумента коллбека, `variant`, который мы берем из итерации цикла и `key` который мы генерируем сами из timestamp.
<br>
А  так же вызваем метод `renderToasts()`.

**Метод `renderToasts()`** <br>
Внутри метода у нас идет проверка на то, есть ли у нас root. Если его нет, ты мы его присваиваем <br>
`root = createRoot(document.getElementById(toastContainerId));`
<br> Здесь мы берем элемент из дома с id = toastContainerId и передаем его как аргумент методу createRoot. <br>

Далее мы вызываем метод у render у root.

```
root.render(
    toasts.map((toast) => {
      setTimeout(() => {
        shouldRemoveAndRender(toast.key);
      }, 3000);

      return (
        <Toast
          key={toast.key}
          message={toast.content}
          variant={toast.variant}
          close={() => {
            shouldRemoveAndRender(toast.key);
          }}
        />
      );
    }),
  );
```
Мы в render передаем массив тостов, проходя по массиву `toasts` мы на каждый тост запускаем таймаут с задержкой в 3000мс, который удалит тост с key = toast.key. В итерации возвращаем компонент `Toast` в который мы передали ключ, контент, вариант отображение и коллбек закрытия тоста.

**Метод `shouldRemoveAndRender()`**
Этот метод принимает в себя один аргумент, key - по которому он отфильтрует и перезапишет массив toasts при вызове и после фильтрации вызовет метод `renderToasts()`
